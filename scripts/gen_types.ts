import path from 'path';
import fs from 'fs-extra';
import { compile } from 'json-schema-to-typescript';

const SCHEMA_DIR_CANDIDATES = [
  path.resolve(__dirname, '../schemas'),
  path.resolve(__dirname, '../vendor/MOVA/schemas'),
  path.resolve(__dirname, '../package/schemas'),
];

const SCHEMA_DIRS = SCHEMA_DIR_CANDIDATES.filter((dir) => fs.existsSync(dir));
const FALLBACK_SCHEMA_DIRS = SCHEMA_DIRS; // reuse discovered dirs for ref resolution

const OUTPUT_DIR = path.resolve(__dirname, '../src/types/generated');
const BANNER = `/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by scripts/gen_types.ts.
 * Do not edit manually. Update JSON Schemas and rerun npm run gen:types.
 */
`;

const MOVA_BASE_URL = 'https://mova.dev/schemas/';
const INLINE_CACHE = new Map<string, any>();

function findSchemaPath(normalized: string, primaryDir: string): string | null {
  const searchDirs = [primaryDir, ...FALLBACK_SCHEMA_DIRS];
  for (const dir of searchDirs) {
    const candidate = path.join(dir, normalized);
    if (fs.existsSync(candidate)) {
      return candidate;
    }
  }
  return null;
}

function rewriteRefs(
  value: any,
  schemaDir: string,
  seenPaths: Set<string> = new Set<string>()
): any {
  if (typeof value === 'string') {
    if (value.startsWith(MOVA_BASE_URL)) {
      const fileName = value.replace(MOVA_BASE_URL, '');
      const normalized = fileName.endsWith('.schema.json') ? fileName : `${fileName}.schema.json`;
      const targetPath = findSchemaPath(normalized, schemaDir);

      if (!targetPath) {
        console.warn(`Warning: could not inline schema for ${value}: not found in known schema dirs`);
        return value;
      }

      if (INLINE_CACHE.has(targetPath)) {
        return INLINE_CACHE.get(targetPath);
      }

      if (seenPaths.has(targetPath)) {
        // Avoid circular refs by returning original $ref
        return value;
      }

      try {
        const targetSchema = fs.readJsonSync(targetPath);
        seenPaths.add(targetPath);
        const rewritten = rewriteRefs(targetSchema, path.dirname(targetPath), seenPaths);
        INLINE_CACHE.set(targetPath, rewritten);
        return rewritten;
      } catch (err) {
        console.warn(`Warning: could not inline schema for ${value}: ${(err as Error).message}`);
        return value;
      }
    }
    return value;
  }

  if (Array.isArray(value)) {
    return value.map((item) => rewriteRefs(item, schemaDir, seenPaths));
  }

  if (value && typeof value === 'object') {
    if ('$ref' in value && typeof (value as any).$ref === 'string') {
      return rewriteRefs((value as any).$ref, schemaDir, seenPaths);
    }

    const next: Record<string, any> = {};
    for (const [k, v] of Object.entries(value)) {
      next[k] = rewriteRefs(v, schemaDir, seenPaths);
    }
    return next;
  }

  return value;
}

async function generateTypes(): Promise<void> {
  if (SCHEMA_DIRS.length === 0) {
    console.error('No schema directories found (checked schemas/, vendor/MOVA/schemas, package/schemas)');
    process.exit(1);
  }

  await fs.ensureDir(OUTPUT_DIR);

  const exported: string[] = [];
  const seen = new Set<string>();

  for (const dir of SCHEMA_DIRS) {
    const entries = await fs.readdir(dir);
    const schemaFiles = entries.filter((f) => f.endsWith('.schema.json')).sort();

    for (const file of schemaFiles) {
      const schemaPath = path.join(dir, file);
      const baseName = file.replace(/\.schema\.json$/, '');

      if (seen.has(baseName)) {
        // Prefer first occurrence (local schemas override vendor duplicates)
        continue;
      }

      const targetPath = path.join(OUTPUT_DIR, `${baseName}.d.ts`);
      const schemaDir = path.dirname(schemaPath);
      const schemaJson = await fs.readJson(schemaPath);
      const rewrittenSchema = rewriteRefs(schemaJson, schemaDir);

      const ts = await compile(rewrittenSchema, baseName, {
        cwd: schemaDir,
        bannerComment: BANNER,
        style: {
          singleQuote: true,
        },
        $refOptions: {
          resolve: {
            file: true,
            http: false, // avoid remote fetch; rely on local schemas
          },
        },
      });

      await fs.writeFile(targetPath, ts, 'utf8');
      exported.push(baseName);
      seen.add(baseName);
      console.log(`Generated ${path.relative(process.cwd(), targetPath)}`);
    }
  }

  const indexContent = `${BANNER}\n${exported
    .map((name) => `export * from './${name}';`)
    .join('\n')}\n`;
  await fs.writeFile(path.join(OUTPUT_DIR, 'index.d.ts'), indexContent, 'utf8');
  console.log(`Generated ${path.relative(process.cwd(), path.join(OUTPUT_DIR, 'index.d.ts'))}`);
}

generateTypes().catch((err) => {
  console.error('Failed to generate types:', err);
  process.exit(1);
});
